
/*
 * Nexus Repository Manager REST API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * API version: 3.68.1-02
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
	"os"
)

// Linger please
var (
	_ context.Context
)

type ComponentsApiService service

/*
ComponentsApiService Delete a single component

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id ID of the component to delete


*/
func (a *ComponentsApiService) DeleteComponent(ctx context.Context, id string) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/components/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/*
ComponentsApiService Get a single component

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param id ID of the component to retrieve

@return ComponentXo
*/
func (a *ComponentsApiService) GetComponentById(ctx context.Context, id string) (ComponentXo, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ComponentXo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/components/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", fmt.Sprintf("%v", id), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ComponentXo
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ComponentsApiService List components

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repository Repository from which you would like to retrieve components
 * @param optional nil or *ComponentsApiGetComponentsOpts - Optional Parameters:
     * @param "ContinuationToken" (optional.String) -  A token returned by a prior request. If present, the next page of results are returned

@return PageComponentXo
*/

type ComponentsApiGetComponentsOpts struct { 
	ContinuationToken optional.String
}

func (a *ComponentsApiService) GetComponents(ctx context.Context, repository string, localVarOptionals *ComponentsApiGetComponentsOpts) (PageComponentXo, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PageComponentXo
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/components"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ContinuationToken.IsSet() {
		localVarQueryParams.Add("continuationToken", parameterToString(localVarOptionals.ContinuationToken.Value(), ""))
	}
	localVarQueryParams.Add("repository", parameterToString(repository, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v PageComponentXo
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/*
ComponentsApiService Upload a single component

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param repository Name of the repository to which you would like to upload the component
 * @param optional nil or *ComponentsApiUploadComponentOpts - Optional Parameters:
     * @param "RAsset" (optional.Interface of *os.File) -  r Asset 
     * @param "RAssetPathId" (optional.String) -  r Asset  Package Path
     * @param "PypiAsset" (optional.Interface of *os.File) -  pypi Asset 
     * @param "HelmAsset" (optional.Interface of *os.File) -  helm Asset 
     * @param "YumDirectory" (optional.String) -  yum Directory
     * @param "YumAsset" (optional.Interface of *os.File) -  yum Asset 
     * @param "YumAssetFilename" (optional.String) -  yum Asset  Filename
     * @param "DockerAsset" (optional.Interface of *os.File) -  docker Asset 
     * @param "RubygemsAsset" (optional.Interface of *os.File) -  rubygems Asset 
     * @param "NugetAsset" (optional.Interface of *os.File) -  nuget Asset 
     * @param "NpmAsset" (optional.Interface of *os.File) -  npm Asset 
     * @param "RawDirectory" (optional.String) -  raw Directory
     * @param "RawAsset1" (optional.Interface of *os.File) -  raw Asset 1
     * @param "RawAsset1Filename" (optional.String) -  raw Asset 1 Filename
     * @param "RawAsset2" (optional.Interface of *os.File) -  raw Asset 2
     * @param "RawAsset2Filename" (optional.String) -  raw Asset 2 Filename
     * @param "RawAsset3" (optional.Interface of *os.File) -  raw Asset 3
     * @param "RawAsset3Filename" (optional.String) -  raw Asset 3 Filename
     * @param "AptAsset" (optional.Interface of *os.File) -  apt Asset 
     * @param "Maven2GroupId" (optional.String) -  maven2 Group ID
     * @param "Maven2ArtifactId" (optional.String) -  maven2 Artifact ID
     * @param "Maven2Version" (optional.String) -  maven2 Version
     * @param "Maven2GeneratePom" (optional.Bool) -  maven2 Generate a POM file with these coordinates
     * @param "Maven2Packaging" (optional.String) -  maven2 Packaging
     * @param "Maven2Asset1" (optional.Interface of *os.File) -  maven2 Asset 1
     * @param "Maven2Asset1Classifier" (optional.String) -  maven2 Asset 1 Classifier
     * @param "Maven2Asset1Extension" (optional.String) -  maven2 Asset 1 Extension
     * @param "Maven2Asset2" (optional.Interface of *os.File) -  maven2 Asset 2
     * @param "Maven2Asset2Classifier" (optional.String) -  maven2 Asset 2 Classifier
     * @param "Maven2Asset2Extension" (optional.String) -  maven2 Asset 2 Extension
     * @param "Maven2Asset3" (optional.Interface of *os.File) -  maven2 Asset 3
     * @param "Maven2Asset3Classifier" (optional.String) -  maven2 Asset 3 Classifier
     * @param "Maven2Asset3Extension" (optional.String) -  maven2 Asset 3 Extension


*/

type ComponentsApiUploadComponentOpts struct { 
	RAsset optional.Interface
	RAssetPathId optional.String
	PypiAsset optional.Interface
	HelmAsset optional.Interface
	YumDirectory optional.String
	YumAsset optional.Interface
	YumAssetFilename optional.String
	DockerAsset optional.Interface
	RubygemsAsset optional.Interface
	NugetAsset optional.Interface
	NpmAsset optional.Interface
	RawDirectory optional.String
	RawAsset1 optional.Interface
	RawAsset1Filename optional.String
	RawAsset2 optional.Interface
	RawAsset2Filename optional.String
	RawAsset3 optional.Interface
	RawAsset3Filename optional.String
	AptAsset optional.Interface
	Maven2GroupId optional.String
	Maven2ArtifactId optional.String
	Maven2Version optional.String
	Maven2GeneratePom optional.Bool
	Maven2Packaging optional.String
	Maven2Asset1 optional.Interface
	Maven2Asset1Classifier optional.String
	Maven2Asset1Extension optional.String
	Maven2Asset2 optional.Interface
	Maven2Asset2Classifier optional.String
	Maven2Asset2Extension optional.String
	Maven2Asset3 optional.Interface
	Maven2Asset3Classifier optional.String
	Maven2Asset3Extension optional.String
}

func (a *ComponentsApiService) UploadComponent(ctx context.Context, repository string, localVarOptionals *ComponentsApiUploadComponentOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/v1/components"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("repository", parameterToString(repository, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
    var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.RAsset.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.RAsset.Value().(*os.File)
		if !localVarFileOk {
				return nil, reportError("rAsset should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if localVarOptionals != nil && localVarOptionals.RAssetPathId.IsSet() {
		localVarFormParams.Add("r.asset.pathId", parameterToString(localVarOptionals.RAssetPathId.Value(), ""))
	}
    var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.PypiAsset.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.PypiAsset.Value().(*os.File)
		if !localVarFileOk {
				return nil, reportError("pypiAsset should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
    var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.HelmAsset.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.HelmAsset.Value().(*os.File)
		if !localVarFileOk {
				return nil, reportError("helmAsset should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if localVarOptionals != nil && localVarOptionals.YumDirectory.IsSet() {
		localVarFormParams.Add("yum.directory", parameterToString(localVarOptionals.YumDirectory.Value(), ""))
	}
    var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.YumAsset.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.YumAsset.Value().(*os.File)
		if !localVarFileOk {
				return nil, reportError("yumAsset should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if localVarOptionals != nil && localVarOptionals.YumAssetFilename.IsSet() {
		localVarFormParams.Add("yum.asset.filename", parameterToString(localVarOptionals.YumAssetFilename.Value(), ""))
	}
    var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.DockerAsset.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.DockerAsset.Value().(*os.File)
		if !localVarFileOk {
				return nil, reportError("dockerAsset should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
    var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.RubygemsAsset.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.RubygemsAsset.Value().(*os.File)
		if !localVarFileOk {
				return nil, reportError("rubygemsAsset should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
    var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.NugetAsset.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.NugetAsset.Value().(*os.File)
		if !localVarFileOk {
				return nil, reportError("nugetAsset should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
    var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.NpmAsset.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.NpmAsset.Value().(*os.File)
		if !localVarFileOk {
				return nil, reportError("npmAsset should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if localVarOptionals != nil && localVarOptionals.RawDirectory.IsSet() {
		localVarFormParams.Add("raw.directory", parameterToString(localVarOptionals.RawDirectory.Value(), ""))
	}
    var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.RawAsset1.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.RawAsset1.Value().(*os.File)
		if !localVarFileOk {
				return nil, reportError("rawAsset1 should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if localVarOptionals != nil && localVarOptionals.RawAsset1Filename.IsSet() {
		localVarFormParams.Add("raw.asset1.filename", parameterToString(localVarOptionals.RawAsset1Filename.Value(), ""))
	}
    var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.RawAsset2.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.RawAsset2.Value().(*os.File)
		if !localVarFileOk {
				return nil, reportError("rawAsset2 should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if localVarOptionals != nil && localVarOptionals.RawAsset2Filename.IsSet() {
		localVarFormParams.Add("raw.asset2.filename", parameterToString(localVarOptionals.RawAsset2Filename.Value(), ""))
	}
    var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.RawAsset3.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.RawAsset3.Value().(*os.File)
		if !localVarFileOk {
				return nil, reportError("rawAsset3 should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if localVarOptionals != nil && localVarOptionals.RawAsset3Filename.IsSet() {
		localVarFormParams.Add("raw.asset3.filename", parameterToString(localVarOptionals.RawAsset3Filename.Value(), ""))
	}
    var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.AptAsset.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.AptAsset.Value().(*os.File)
		if !localVarFileOk {
				return nil, reportError("aptAsset should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if localVarOptionals != nil && localVarOptionals.Maven2GroupId.IsSet() {
		localVarFormParams.Add("maven2.groupId", parameterToString(localVarOptionals.Maven2GroupId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Maven2ArtifactId.IsSet() {
		localVarFormParams.Add("maven2.artifactId", parameterToString(localVarOptionals.Maven2ArtifactId.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Maven2Version.IsSet() {
		localVarFormParams.Add("maven2.version", parameterToString(localVarOptionals.Maven2Version.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Maven2GeneratePom.IsSet() {
		localVarFormParams.Add("maven2.generate-pom", parameterToString(localVarOptionals.Maven2GeneratePom.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Maven2Packaging.IsSet() {
		localVarFormParams.Add("maven2.packaging", parameterToString(localVarOptionals.Maven2Packaging.Value(), ""))
	}
    var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.Maven2Asset1.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.Maven2Asset1.Value().(*os.File)
		if !localVarFileOk {
				return nil, reportError("maven2Asset1 should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if localVarOptionals != nil && localVarOptionals.Maven2Asset1Classifier.IsSet() {
		localVarFormParams.Add("maven2.asset1.classifier", parameterToString(localVarOptionals.Maven2Asset1Classifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Maven2Asset1Extension.IsSet() {
		localVarFormParams.Add("maven2.asset1.extension", parameterToString(localVarOptionals.Maven2Asset1Extension.Value(), ""))
	}
    var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.Maven2Asset2.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.Maven2Asset2.Value().(*os.File)
		if !localVarFileOk {
				return nil, reportError("maven2Asset2 should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if localVarOptionals != nil && localVarOptionals.Maven2Asset2Classifier.IsSet() {
		localVarFormParams.Add("maven2.asset2.classifier", parameterToString(localVarOptionals.Maven2Asset2Classifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Maven2Asset2Extension.IsSet() {
		localVarFormParams.Add("maven2.asset2.extension", parameterToString(localVarOptionals.Maven2Asset2Extension.Value(), ""))
	}
    var localVarFile *os.File
	if localVarOptionals != nil && localVarOptionals.Maven2Asset3.IsSet() {
		localVarFileOk := false
		localVarFile, localVarFileOk = localVarOptionals.Maven2Asset3.Value().(*os.File)
		if !localVarFileOk {
				return nil, reportError("maven2Asset3 should be *os.File")
		}
	}
	if localVarFile != nil {
		fbs, _ := ioutil.ReadAll(localVarFile)
		localVarFileBytes = fbs
		localVarFileName = localVarFile.Name()
		localVarFile.Close()
	}
	if localVarOptionals != nil && localVarOptionals.Maven2Asset3Classifier.IsSet() {
		localVarFormParams.Add("maven2.asset3.classifier", parameterToString(localVarOptionals.Maven2Asset3Classifier.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Maven2Asset3Extension.IsSet() {
		localVarFormParams.Add("maven2.asset3.extension", parameterToString(localVarOptionals.Maven2Asset3Extension.Value(), ""))
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

